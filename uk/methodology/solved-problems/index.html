<!DOCTYPE html><html class="ua_js_no"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Які проблеми вирішує / Методологія / БЕМ</title><script>(function(e,c){e[c]=e[c].replace(/(ua_js_)no/g,"$1yes");})(document.documentElement,"className");</script><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,600,700&amp;subset=cyrillic"/><link rel="stylesheet" href="/bem.info/uk/methodology.min.css"/><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/><meta property="og:image" content="https://ru.bem.info/og_image/logo_theme_stripe.png"/><meta property="og:url" content="/methodology/solved-problems/"/><meta property="og:type" content="article"/><meta property="og:description" content="Які проблеми вирішує"/><meta property="og:keywords" content="methodology"/><link rel="shortcut icon" href="/bem.info/uk/favicon.ico"/></head><body class="page"><div class="header i-bem" data-bem='{"header":{}}'><div class="header__layout"><a class="logo header__logo" href="/bem.info/uk/"><svg class="logo__logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 101.7 84"><path d="M0 13h23.8v7H0zM0 0h23.8v7H0zm42.7 25.9H0v7h41.1c4.5 0 15 .1 18.9 6.4v-3.9c-1.9-6.2-7.5-9.5-17.3-9.5zm.1 13H0v7h41.1c10 0 16.3.4 18.9 1.8v-3.1c-2-4.9-10.4-5.7-17.2-5.7zm-.1 33H0v-7h41.1c4.5 0 15-.1 18.9-6.4v3.9c-1.9 6.2-7.5 9.5-17.3 9.5zm.1-13H0v-7h41.1c10 0 16.3-.4 18.9-1.8v3.1c-2 4.9-10.4 5.7-17.2 5.7zM70.4 84h31.4v-4.3H71.3c-2.7 0-9.1-.1-11.4-3.8v2.4C61 82 64.4 84 70.4 84zm-.1-7.9h31.4v-4.3H71.3c-6.1 0-9.9-.2-11.4-1.1v1.9c1.2 3 6.3 3.5 10.4 3.5z"/></svg></a><ul class="lang-switcher header__lang"><li class="lang-switcher__item"><a class="lang-switcher__link" href="/bem.info/en/methodology/solved-problems/">en</a></li><li class="lang-switcher__item"><a class="lang-switcher__link" href="/bem.info/ru/methodology/solved-problems/">ru</a></li><li class="lang-switcher__item lang-switcher__item_current">uk</li></ul><a class="header__forum" href="https://ru.bem.info/forum/">Форум</a></div><div class="search header__search i-bem" data-bem='{"search":{}}'><form class="form search__form search__form_site_methodology i-bem" data-bem='{"form":{}}' action="https://yandex.com/sitesearch"><span class="input input_type_search i-bem" data-bem='{"input":{}}'><span class="input__box"><input class="input__control" name="text" placeholder="Search" autocomplete="off" type="search"/></span></span><input type="hidden" name="reqenc"/><input type="hidden" name="searchid" value="1944806"/><input type="hidden" name="l10n" value="uk"/><div class="search-icon search__submit"><svg viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg"><circle cx="7" cy="7" r="6"/><path d="M11 11l5 5"/></svg></div></form></div><div class="header__menu"><ul class="breadcrumbs header__breadcrumbs"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/bem.info/uk/methodology/">Методологія</a></li></ul><ul class="nav"><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/key-concepts/">Основні поняття</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/naming-convention/">Угода щодо іменування</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/js/">JavaScript</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/js-principles/">Особливості JavaScript</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/filesystem/">Файлова система</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/build/">Збірка</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/declarations/">Декларації</a></li><li class="nav__item nav__item_current">Які проблеми вирішує</li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/history/">Історія створення</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/articles/">Статті</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/faq/">FAQ</a></li></ul></div><div class="header__toggle search-icon"><span class="header__toggle-line"></span></div></div><div class="sitemap i-bem" data-bem='{"sitemap":{}}'><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_methodology"><a class="sitemap__link" href="/bem.info/uk/methodology/">Методологія</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/key-concepts/">Основні поняття</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/naming-convention/">Угода щодо іменування</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/js/">JavaScript</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/js-principles/">Особливості JavaScript</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/filesystem/">Файлова система</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/build/">Збірка</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/declarations/">Декларації</a></li><li class="sitemap__tree-item-1"><strong class="sitemap__current">Які проблеми вирішує</strong></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/history/">Історія створення</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/articles/">Статті</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/faq/">FAQ</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_tools"><a class="sitemap__link" href="https://ru.bem.info/tools/">Інструментарій</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/tools/bem/bem-tools/">bem-tools</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/tools/bem/enb-bem/">enb-bem</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link">Модулі</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/tools/bem/bem-naming/">bem-naming</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_platform"><a class="sitemap__link">Платформа</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link">Технології</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="https://ru.bem.info/technology/i-bem/v2/i-bem-js/">i-bem</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/technology/deps/about/">DEPS</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="https://ru.bem.info/technology/bemjson/v2/bemjson/">BEMJSON</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="https://ru.bem.info/technology/bemhtml/v2/intro/">BEMHTML</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="https://ru.bem.info/technology/bemtree/v2/bemtree/">BEMTREE</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/libs/">Бібліотеки</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/libs/bem-core/">bem-core</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/libs/bem-components/">bem-components</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/libs/bem-history/">bem-history</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_community"><a class="sitemap__link" href="/bem.info/uk/community/">Спільнота</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/blog/">Блог</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/events/">Події</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/forum/">Форум</a></li></ul></div></div><div class="content"><div class="article-wrap"><div class="article"><ul class="article-tags"><li class="article-tags__tag"><a class="article-tags__link" href="/bem.info/uk/tags/methodology">methodology</a></li></ul><h1 class="article__heading article__heading_1" id="Рішення-типових-проблем-веб-розробки-з-допомогою-БЕМ"><a href="#Рішення-типових-проблем-веб-розробки-з-допомогою-БЕМ" class="article__heading-anchor"></a>Рішення типових проблем веб-розробки з допомогою БЕМ</h1><p>Методологія БЕМ задає <a href="../naming-convention/naming-convention.ru.md">правила іменування CSS селекторів</a>, дотримання яких вирішує ряд проблем веб-розробки і відповідає на наступні питання:</p>
<ul>
<li><a href="#Як-спростити-код-і-полегшити-рефакторинг">Як спростити код і полегшити рефакторинг</a></li>
<li><a href="#Як-отримати-самодокументируемый-код">Як отримати самодокументируемый код</a></li>
<li><a href="#Як-почати-повторно-використовувати-код-і-уникнути взаємного впливу-компонентів-один-на-одного">Як почати повторно використовувати код і уникнути взаємного впливу компонентів один на одного</a></li>
<li><a href="#Як-the-кілька-сутностей-на-одному-dom-сайті-і-уникнути-copy-paste">Як розмістити кілька сутностей на одному DOM-вузлі і уникнути «Copy-Paste»</a></li>
</ul>
<h2 class="article__heading article__heading_2" id="Як-спростити-код-і-полегшити-рефакторинг"><a href="#Як-спростити-код-і-полегшити-рефакторинг" class="article__heading-anchor"></a>Як спростити код і полегшити рефакторинг</h2><p><strong>Проблема</strong></p>
<p>При верстці проекту компоненти інтерфейсу отримують імена на основі контексту, з яким працює розробник. Зазвичай контекстом служить сторінка або якась її частина.</p>
<p>Коли сторінку верстає один розробник в короткі терміни, колізії імен можна уникнути. Але якщо над проектом працюють кілька осіб або правки потрібно внести через якийсь час, то відстежити залежні імена компонентів стає складно. У великих проектах результатом правки одного класу може стати десяток «роз&#39;їхалися» сторінок.</p>
<p>Наприклад, для створення навігаційного меню можуть використовуватися такі імена класів:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>До них можуть бути написані CSS-правил:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.active</span>
{
    <span class="hljs-attribute">font-weight</span>: bold;
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffc7c7</span>;
}
</code></pre>
<p>Якщо знадобиться додати на сторінку інший компонент, що містить пункти, стилі для нового <code>item</code> вплинуть на пункти з існуючого навігаційного меню.</p>
<p>Або припустимо, що в навігаційному меню потрібно змінити правила класу <code>.active</code>. По імені незрозуміло компоненти, які його використовують. Може виявитися, що на іншій сторінці існує, наприклад, кнопка <code>&lt;div class=&quot;button active&quot;&gt;Натисни мене!&lt;/div&gt;</code>. Тоді зміна правил для <code>.active</code> вплине на стилі цієї кнопки.</p>
<p>Щоб розібратися, чи можна безболісно змінити стилі для класу <code>.active</code>, розробнику доведеться переглянути всю структуру сторінки або проекту. Будь-яка зміна потребуватиме значних часових витрат тільки на пошук залежних компонентів.</p>
<p><strong>Рішення</strong></p>
<p>Методологія БЕМ вирішує проблему колізії імен за допомогою <a href="../naming-convention/naming-convention.ru.md#Угода-по-іменування-css%20селекторів">угоди щодо іменування CSS-класів</a>, надаючи всім компонентів та їх складових унікальні імена.</p>
<p>Застосування правил іменування дозволяє:</p>
<ul>
<li>задавати унікальні імена <a href="../key-concepts/key-concepts.ru.md#БЕМ-сутність">БЕМ-сутностей</a>;</li>
<li>відстежувати ієрархічні зв&#39;язки в межах блоку;</li>
<li>спрощувати сприйняття коду;</li>
<li>отримувати <a href="#Як-отримати-самодокументируемый-код">самодокументируемый код</a>.</li>
</ul>
<p>Розглянемо той же приклад навігаційного меню:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>Але застосуємо до нього правила іменування БЕМ: клас <code>nav</code> буде позначати ім&#39;я блоку, <code>nav__item</code> і <code>nav__link</code> — імена елементів, а <code>nav__item_active</code> — ім&#39;я модифікатора елемента <code>item</code>.</p>
<p>У такому випадку запис буде наступною:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item nav__item_active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>І, відповідно, CSS буде мати такий вигляд:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.nav__item_active</span>
{
    <span class="hljs-attribute">font-weight</span>: bold;
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffc7c7</span>;
}
</code></pre>
<p>Нові імена CSS-класів містять всю інформацію про структуру блоку. А це значить, що більше не потрібно переглядати HTML-код сторінки, щоб визначити всі залежності. Селектор завжди містить знання про те, на який блок або елемент впливають його правила (в даному випадку на елемент <code>nav__item</code>). Розробникам не доведеться думати про можливе існування кнопки <code>&lt;div class=&quot;button active&quot;&gt;Натисни мене!&lt;/div&gt;</code>, так як її CSS-правила будуть записані як <code>.button_active</code> і не будуть залежати від правил модифікатора <code>active</code> для пункту меню (<code>nav__item_active</code>).</p>
<blockquote>
<p>Використання довгих імен має наступні недоліки:</p>
<ul>
<li><p>Результуючий код важить більше. Ця проблема вирішується <code>gzip</code>, який стискає повторювані послідовності в іменах.</p>
</li>
<li><p>Часу на написання класів витрачається більше. Цю проблему допомагають вирішити автозаповнення в редакторі, використання CSS препроцесорів і шаблонизаторов, які автоматично додають префікси. Довгі імена класів надають явні зв&#39;язки між складовими частинами компонентів, що економить час на вивчення архітектури проекту.</p>
</li>
</ul>
</blockquote>
<h3 class="article__heading article__heading_3" id="Як-отримати-самодокументируемый-код"><a href="#Як-отримати-самодокументируемый-код" class="article__heading-anchor"></a>Як отримати самодокументируемый код</h3><p><strong>Проблема</strong></p>
<p>При переході на новий проект розробник витрачає багато зусиль на те, щоб зрозуміти, як все влаштовано, де що лежить і як працює код. Часом саме на таке вивчення йде велика частина часу, а зовсім не на реалізацію функціональності або виправлення помилки.</p>
<p><strong>Рішення</strong></p>
<p>Одна з цілей БЕМ — дати зрозуміти, що робить той чи інший код, тільки за назвами класів. Ідея самодокументируемого коду полягає в тому, щоб при перегляді CSS-класів, змінних і функцій було зрозуміло, як працює код, і як взаємодіють компоненти інтерфейсу.</p>
<p>Використовуючи БЕМ, можна отримати HTML з іменами класів, показують взаємодію таких частин коду:</p>
<ul>
<li>незалежних <a href="../key-concepts/key-concepts.ru.md#Блок">блоків</a>;</li>
<li><a href="../key-concepts/key-concepts.ru.md#Елемент">елементів</a> (дочірніх компонентів) цього блоку;</li>
<li><a href="../key-concepts/key-concepts.ru.md#Модифікатор">модифікаторів</a> блоку або елемента.</li>
</ul>
<p>Розглянемо приклад з формою пошуку на сайті. Не будемо звертатися до HTML, спробуємо прочитати тільки CSS і зрозуміти, яку частину інтерфейсу він описує.</p>
<p>Варіант реалізації форми в класичній верстання:</p>
<pre><code class="lang-css"><span class="hljs-selector-tag">form</span> {}

<span class="hljs-selector-tag">input</span>
{
    <span class="hljs-attribute">background</span>: red;
}

<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=submit]</span>
{
    <span class="hljs-attribute">background</span>: buttonface
}
</code></pre>
<p>Такий спосіб запису не відображає зв&#39;язок між:</p>
<ul>
<li>компонентами та їх складовими частинами;</li>
<li>селекторами і конкретними компонентами інтерфейсу, до яких вони відносяться.</li>
</ul>
<p>Використання глобальних селекторів робить код проекту нерасширяемым, так як внесення мінімальних змін спричинить за собою виправлення у всіх залежних правилах.</p>
<p>Напишемо CSS на класи:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.form</span> {}
<span class="hljs-selector-class">.field</span> {}
<span class="hljs-selector-class">.submit</span> {}
</code></pre>
<p>Код став інформації: тепер зрозуміло, що є форма, поле і якийсь компонент <code>submit</code>. Але такі імена все ще не дають зрозуміти, чи відноситься поле (<code>field</code>) до формі (<code>form</code>), або що станеться, якщо полів або форм на сторінці буде кілька. Знову виникає необхідність звертатися до HTML.</p>
<p>Перепишемо приклад, використовуючи <a href="../naming-convention/naming-convention.ru.md">угода щодо іменування БЕМ</a>:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.form</span> {}
<span class="hljs-selector-class">.form_search</span> {}
<span class="hljs-selector-class">.form__field</span> {}
<span class="hljs-selector-class">.form__submit-button</span> {}
</code></pre>
<p>Такий запис дає зрозуміти, як працює даний код. Імена CSS-класів показують, що:</p>
<ul>
<li>Існує форма, реалізована блоком <code>form</code>.</li>
<li>Модифікатор <code>form_search</code> вказує на те, що мова йде про форму пошуку.</li>
<li>У форми є складові — вкладені елементи: поле <code>form__field</code> кнопка <code>form__submit-button</code>.</li>
</ul>
<p>Дотримання угоди щодо іменування БЕМ дозволяє зрозуміти структуру блоку без докладного вивчення HTML. Навіть при появі на сторінці ще одного поля (крім <code>form__field</code>), його правила ніяк не будуть впливати на елементи пошукової форми. Нове поле буде реалізовано як елемент іншого блоку і буде мати своє унікальне ім&#39;я. Наприклад, <code>attach__field</code>.</p>
<p>Правила іменування БЕМ дозволяють зробити код проекту однозначним і, як наслідок, інформативним. Це знижує поріг входу для інших розробників.</p>
<h2 class="article__heading article__heading_2" id="Як-почати-повторно-використовувати-код-і-уникнути-взаємного-впливу-компонентів-один-на-одного"><a href="#Як-почати-повторно-використовувати-код-і-уникнути-взаємного-впливу-компонентів-один-на-одного" class="article__heading-anchor"></a>Як почати повторно використовувати код і уникнути взаємного впливу компонентів один на одного</h2><p><strong>Проблема</strong></p>
<p>Розробник використовує схожий набір компонентів при розробці сторінок одного проекту. Наприклад, на сторінці може бути кілька типів блоку <code>menu</code>.</p>
<p>Розглянемо проблему на прикладі навігаційного меню:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>CSS-стилі до пункту <code>item</code> можуть бути записані як:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}
</code></pre>
<p>Якщо на сторінку знадобиться додати додаткові компоненти, що містять пункти, то з&#39;явиться ще один блок коду з класом <code>item</code>, наприклад:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumb"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>У цьому випадку CSS може бути оформлений за допомогою каскадів. Для цього достатньо довизначити правила, вже написані для <code>.item</code>:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.snippets</span> <span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
}
</code></pre>
<p>Такий код може працювати до тих пір, поки не виникне необхідність змінити сторінку. Наприклад, перемістити пункти меню, використовувати написаний код у іншому місці окремо від батьківського компонента або вкласти навігаційне меню в блок <code>snippets</code>.</p>
<p>Використання каскадів пов&#39;язує незалежні компоненти інтерфейсу: немає можливості виправити один компонент, не торкнувшись стилі іншого.</p>
<p><strong>Рішення</strong></p>
<p><a href="../naming-convention/naming-convention.ru.md">Правила іменування CSS селекторів</a> дають можливість вносити зміни точково, не зачіпаючи залежні компоненти. У БЕМ кожен блок має унікальне ім&#39;я і є самодостатнім.</p>
<p>Запишемо той же код згідно з правилами іменування БЕМ:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}
</code></pre>
<p>У такому разі додавання нового пункту <code>item</code> на сторінку буде виглядати так:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__item"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__thumb"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>Пункт <code>snippets__item</code> буде мати відповідні тільки йому унікальні CSS-правил:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.snippets__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
}
</code></pre>
<p>Зміни в <code>nav__item</code> не впливають на <code>snippets__item</code>, так як пункти отримують унікальні імена завдяки <a href="https://ru.wikipedia.org/wiki/Пространство_имен_%28программирование%29">простору імен</a>, заданим ім&#39;ям блоку. Це дозволяє формувати незалежні CSS-правила для всіх елементів блоку.</p>
<p>Такой подход дает возможность защитить элементы от взаимного влияния друг на друга — элементы всегда являются частью блока. Такий же принцип роботи використовує і Shadow DOM в Web Components. Але, на відміну від Shadow DOM, застосування угоди щодо іменування БЕМ не залежить від сумісності з роботою браузерів.</p>
<p>Блоки <code>snippets</code> і <code>nav</code> можна повторно використовувати і переміщати по сторінці або проектом. Унікальність імен класів, заснована на правилах іменування БЕМ, дозволяє блокам не залежати один від одного.</p>
<h3 class="article__heading article__heading_3" id="Використання-каскадів-у-БЕМ"><a href="#Використання-каскадів-у-БЕМ" class="article__heading-anchor"></a>Використання каскадів у БЕМ</h3><p>Методологія БЕМ допускає використання каскадів.</p>
<p>Наприклад, каскад доречний, щоб змінювати елементи в залежності від стану блоку або заданої йому теми:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav_hovered</span> <span class="hljs-selector-class">.nav__link</span>
{
    <span class="hljs-attribute">text-decoration</span>: underline;
}
</code></pre>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav_theme_islands</span> <span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;
}
</code></pre>
<hr>
<p><strong>Важливо!</strong> Застосування каскаду збільшує зв&#39;язаність коду і робить його повторне використання неможливим.</p>
<hr>
<h2 class="article__heading article__heading_2" id="Як-розмістити-кілька-сутностей-на-одному-dom-вузлі-і-уникнути-«copy-paste»"><a href="#Як-розмістити-кілька-сутностей-на-одному-dom-вузлі-і-уникнути-«copy-paste»" class="article__heading-anchor"></a>Як розмістити кілька сутностей на одному DOM-вузлі і уникнути «Copy-Paste»</h2><p><strong>Проблема</strong></p>
<p>При роботі з проектами може знадобитися повторно використовувати реалізовану функціональність.</p>
<p>У багатьох випадках таку проблему вирішують копіюванням потрібної частини коду в новий компонент. Такий підхід має наступні недоліки:</p>
<ul>
<li>збільшується кодова база проекту;</li>
<li>може налагодження коду при виявленні помилки.</li>
</ul>
<p>Як наслідок, розробник змушений підтримувати більшу кількість рядків коду, а виправлення треба вносити окремо в кожну реалізацію. Це збільшує часові витрати на налагодження і підтримку проекту.</p>
<p><strong>Рішення</strong></p>
<p>Скористаємося прикладом, який реалізує універсальний блок навігаційного меню та написаний за всіма <a href="../naming-convention/naming-convention.ru.md">правилами іменування БЕМ</a>.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>Такий блок можна використовувати, наприклад, для навігації по статтям в блоці новин.</p>
<p>Припустимо, в розділі новин вже є блок <code>articles</code>, якому написані всі необхідні CSS-правила.</p>
<p>Змішати реалізації двох різних блоків без копіювання коду можна за допомогою <a href="../key-concepts/key-concepts.ru.md#Мікс">міксу</a>. Тобто розмістити на одному DOM-сайті блок <code>nav</code> елемент <code>articles__nav</code>.</p>
<p>У коді це буде виглядати так:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav articles__nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>Така реалізація дозволить об&#39;єднати функціональність блоку <code>nav</code> і особливості реалізації елемента <code>articles__nav</code> (зовнішній вигляд новинних статей в меню). При цьому немає необхідності копіювати вже наявні CSS-правила. При виявленні помилки, виправлення необхідно буде внести тільки одну частину коду.</p>
<blockquote>
<p>Міксувати можна не тільки блоки з елементами, але і інші БЕМ-сутності. Детальніше про варіанти використання міксів в БЕМ читайте у розділі <a href="../key-concepts/key-concepts.ru.md#Мікс">Основні поняття БЕМ</a>.</p>
</blockquote>
</div><ul class="article-rewind"><li class="article-rewind__prev"><a class="article-rewind__prev-link" href="/bem.info/uk/methodology/declarations/">Декларації</a></li> <li class="article-rewind__next"><a class="article-rewind__next-link" href="/bem.info/uk/methodology/history/">Історія створення</a></li></ul><div class="article-amendments">Якщо ви помітили помилку, або хочете доповнити статтю, ви завжди можете або написати нам про це на <a class="article-amendments__issue" href="https://github.com/bem/bem-method/issues/new">Гітхабі</a>, або поправити статтю з допомогою <a class="article-amendments__edit" href="http://prose.io/#bem/bem-method/blob/bem-info-data/method/solved-problems/solved-problems.uk.md">prose.io.</a></div><div class="social-likes"><a class="social-likes__text">Поділитися зі світом: </a><a class="social-likes__service social-likes__service_type_facebook" href="https://www.facebook.com/sharer.php?s=100&amp;url=https%3A%2F%2Fuk.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=%D0%AF%D0%BA%D1%96%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B8%20%D0%B2%D0%B8%D1%80%D1%96%D1%88%D1%83%D1%94&amp;image=">Facebook</a> <a class="social-likes__service social-likes__service_type_vk" href="http://vk.com/share.php?&amp;url=https%3A%2F%2Fuk.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=%D0%AF%D0%BA%D1%96%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B8%20%D0%B2%D0%B8%D1%80%D1%96%D1%88%D1%83%D1%94&amp;image=">VKontakte</a> <a class="social-likes__service social-likes__service_type_twitter" href="https://twitter.com/share?&amp;url=https%3A%2F%2Fuk.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=%D0%AF%D0%BA%D1%96%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B8%20%D0%B2%D0%B8%D1%80%D1%96%D1%88%D1%83%D1%94&amp;image=">Twitter</a></div></div></div><footer class="footer page-bg"><div class="legos legos_inverted"><div class="legos__lego legos__lego_height_4 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_6"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_6"></div><div class="legos__lego legos__lego_height_4 legos__lego_width_6"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_7"></div><div class="legos__lego legos__lego_height_1 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_4 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_1"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_6"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_4 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_1 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_7"></div><div class="legos__lego legos__lego_height_1 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_4 legos__lego_width_2"></div></div><div class="footer__layout"><ul class="footer__community"><li class="footer__channel"><a class="footer__channel-link" href="https://web-standards.slack.com/messages/bem/">Slack</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://telegram.me/bem_ru">Telegram</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://www.facebook.com/groups/bem.info/">Facebook</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://twitter.com/bem_ru/">Twitter</a></li></ul></div></footer><script>(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter16972024 = new Ya.Metrika({"id":"16972024","webvisor":true,"clickmap":true,"trackLinks":true,"accurateTrackBounce":true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/16972024" style="position:absolute; left:-9999px;"/></div></noscript><script src="/bem.info/uk/methodology.uk.min.js"></script></body></html>