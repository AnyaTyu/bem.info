<!DOCTYPE html><html class="ua_js_no"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>FAQ / Методологія / БЕМ</title><script>(function(e,c){e[c]=e[c].replace(/(ua_js_)no/g,"$1yes");})(document.documentElement,"className");</script><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,600,700&amp;subset=cyrillic"/><link rel="stylesheet" href="/bem.info/uk/methodology.min.css"/><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/><meta property="og:image" content="https://ru.bem.info/og_image/logo_theme_stripe.png"/><meta property="og:url" content="/methodology/faq/"/><meta property="og:type" content="article"/><meta property="og:description" content="FAQ"/><meta property="og:keywords" content="methodology"/><link rel="shortcut icon" href="/bem.info/uk/favicon.ico"/></head><body class="page"><div class="header i-bem" data-bem='{"header":{}}'><div class="header__layout"><a class="logo header__logo" href="/bem.info/uk/"><svg class="logo__logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 101.7 84"><path d="M0 13h23.8v7H0zM0 0h23.8v7H0zm42.7 25.9H0v7h41.1c4.5 0 15 .1 18.9 6.4v-3.9c-1.9-6.2-7.5-9.5-17.3-9.5zm.1 13H0v7h41.1c10 0 16.3.4 18.9 1.8v-3.1c-2-4.9-10.4-5.7-17.2-5.7zm-.1 33H0v-7h41.1c4.5 0 15-.1 18.9-6.4v3.9c-1.9 6.2-7.5 9.5-17.3 9.5zm.1-13H0v-7h41.1c10 0 16.3-.4 18.9-1.8v3.1c-2 4.9-10.4 5.7-17.2 5.7zM70.4 84h31.4v-4.3H71.3c-2.7 0-9.1-.1-11.4-3.8v2.4C61 82 64.4 84 70.4 84zm-.1-7.9h31.4v-4.3H71.3c-6.1 0-9.9-.2-11.4-1.1v1.9c1.2 3 6.3 3.5 10.4 3.5z"/></svg></a><ul class="lang-switcher header__lang"><li class="lang-switcher__item"><a class="lang-switcher__link" href="/bem.info/en/methodology/faq/">en</a></li><li class="lang-switcher__item"><a class="lang-switcher__link" href="/bem.info/ru/methodology/faq/">ru</a></li><li class="lang-switcher__item lang-switcher__item_current">uk</li></ul><a class="header__forum" href="https://ru.bem.info/forum/">Форум</a></div><div class="search header__search i-bem" data-bem='{"search":{}}'><form class="form search__form search__form_site_methodology i-bem" data-bem='{"form":{}}' action="https://yandex.com/sitesearch"><span class="input input_type_search i-bem" data-bem='{"input":{}}'><span class="input__box"><input class="input__control" name="text" placeholder="Search" autocomplete="off" type="search"/></span></span><input type="hidden" name="reqenc"/><input type="hidden" name="searchid" value="1944806"/><input type="hidden" name="l10n" value="uk"/><div class="search-icon search__submit"><svg viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg"><circle cx="7" cy="7" r="6"/><path d="M11 11l5 5"/></svg></div></form></div><div class="header__menu"><ul class="breadcrumbs header__breadcrumbs"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/bem.info/uk/methodology/">Методологія</a></li></ul><ul class="nav"><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/key-concepts/">Основні поняття</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/naming-convention/">Угода щодо іменування</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/js/">JavaScript</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/js-principles/">Особливості JavaScript</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/filesystem/">Файлова система</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/build/">Збірка</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/declarations/">Декларації</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/solved-problems/">Які проблеми вирішує</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/history/">Історія створення</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/uk/methodology/articles/">Статті</a></li><li class="nav__item nav__item_current">FAQ</li></ul></div><div class="header__toggle search-icon"><span class="header__toggle-line"></span></div></div><div class="sitemap i-bem" data-bem='{"sitemap":{}}'><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_methodology"><a class="sitemap__link" href="/bem.info/uk/methodology/">Методологія</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/key-concepts/">Основні поняття</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/naming-convention/">Угода щодо іменування</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/js/">JavaScript</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/js-principles/">Особливості JavaScript</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/filesystem/">Файлова система</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/build/">Збірка</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/declarations/">Декларації</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/solved-problems/">Які проблеми вирішує</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/history/">Історія створення</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/uk/methodology/articles/">Статті</a></li><li class="sitemap__tree-item-1"><strong class="sitemap__current">FAQ</strong></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_tools"><a class="sitemap__link" href="https://ru.bem.info/tools/">Інструментарій</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/tools/bem/bem-tools/">bem-tools</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/tools/bem/enb-bem/">enb-bem</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link">Модулі</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/tools/bem/bem-naming/">bem-naming</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_platform"><a class="sitemap__link">Платформа</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link">Технології</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="https://ru.bem.info/technology/i-bem/v2/i-bem-js/">i-bem</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/technology/deps/about/">DEPS</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="https://ru.bem.info/technology/bemjson/v2/bemjson/">BEMJSON</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="https://ru.bem.info/technology/bemhtml/v2/intro/">BEMHTML</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="https://ru.bem.info/technology/bemtree/v2/bemtree/">BEMTREE</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/libs/">Бібліотеки</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/libs/bem-core/">bem-core</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/libs/bem-components/">bem-components</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="https://ru.bem.info/libs/bem-history/">bem-history</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_community"><a class="sitemap__link" href="/bem.info/uk/community/">Спільнота</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/blog/">Блог</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/events/">Події</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="https://ru.bem.info/forum/">Форум</a></li></ul></div></div><div class="content"><div class="article-wrap"><div class="article"><ul class="article-tags"><li class="article-tags__tag"><a class="article-tags__link" href="/bem.info/uk/tags/methodology">methodology</a></li></ul><h1 class="article__heading article__heading_1" id="Часті-питання"><a href="#Часті-питання" class="article__heading-anchor"></a>Часті питання</h1><h2 class="article__heading article__heading_2" id="Чому-БЕМ"><a href="#Чому-БЕМ" class="article__heading-anchor"></a>Чому БЕМ?</h2><ul>
<li><a href="#У-відмінність-БЕМ-від-oocss-amcss-smacss-suitcss">У чому відмінність БЕМ від OOCSS, AMCSS, SMACSS, SUITCSS?</a></li>
<li><a href="#- Різниця-між-БЕМ-і-web-components">У чому різниця між БЕМ і Web Components?</a></li>
<li><a href="#- Різниця-між-БЕМ-і-bootstrap">У чому різниця між БЕМ і Bootstrap?</a></li>
</ul>
<h2 class="article__heading article__heading_2" id="Блоки-та-елементи"><a href="#Блоки-та-елементи" class="article__heading-anchor"></a>Блоки та елементи</h2><ul>
<li><a href="#У-будь-разі-створювати блок--якому--елемент">В якому разі створювати блок, у якому — елемент?</a></li>
<li><a href="#Почему-в-БЭМ-не-рекомендуется-создавать-элементы-элементов-block__elem1__elem2">Чому в БЕМ не рекомендується створювати елементи елементів (block<strong>elem1</strong>elem2)?</a></li>
<li><a href="#Навіщо писати-ім&#39;я-блоку в іменах-модифікаторів-і-елементів">Навіщо писати ім&#39;я блоку в іменах модифікаторів і елементів?</a></li>
<li><a href="#Як зробити-глобальні-модифікатори-для-блоків">Як зробити глобальні модифікатори для блоків?</a></li>
<li><a href="#Навіщо створювати окремі-директорії і файли-для-кожного блоку-і-технології">Навіщо створювати окремі директорії і файли для кожного блоку і технології?</a></li>
</ul>
<h2 class="article__heading article__heading_2" id="javascript"><a href="#javascript" class="article__heading-anchor"></a>JavaScript</h2><ul>
<li><a href="#Навіщо використовувати-i-bemjs-якщо можна-писати-на-jquery">Навіщо використовувати i-bem.js якщо можна писати на jQuery?</a></li>
</ul>
<h2 class="article__heading article__heading_2" id="css"><a href="#css" class="article__heading-anchor"></a>CSS</h2><ul>
<li><a href="#Чомусь небажано використовувати вкладені-селектори">Чому небажано використовувати вкладені селектори?</a></li>
<li><a href="#Почему-в-БЭМ-не-рекомендуется-использовать-комбинированные-селекторы-для-создания-css-правил-к-модификатору">Чому в БЕМ не рекомендується використовувати комбіновані селектори для створення CSS-правил до модификатору?</a></li>
<li><a href="#Можна об&#39;єднувати-тег-та-клас-у-селекторі-Наприклад-buttonbutton">Можна об&#39;єднувати тег і клас в селекторі (наприклад, button.button)?</a></li>
<li><a href="#Чому-у-БЕМ-не-використовують-користувальницькі теги-custom-tags-для-блоків">Чому в БЕМ не використовують користувальницькі теги (custom tag) для блоків?</a></li>
<li><a href="#Чомусь не можна робити-загальний-скидання-стилів-reset">Чому не можна робити загальний скид стилів (reset)?</a></li>
<li><a href="#Почему-нельзя-писать-block_mod-вместо-block-block_mod-если-имя-модификатора-уже-содержит-всю-информацию-о-блоке">Чому не можна писати block_mod замість block block_mod, якщо ім&#39;я модифікатора вже містить всю інформацію про блоке?</a></li>
<li><a href="#Почему-нельзя-указывать-название-css-свойства-в-имени-модификатора-block__element_border-color_grey">Чому не можна вказувати назву CSS-властивості в імені модифікатора: .block__element_border-color_grey?</a></li>
</ul>
<p><strong>Не знайшли відповідь?</strong> — <a href="https://ru.bem.info/forum/">Задайте питання команді на форумі</a></p>
<h2 class="article__heading article__heading_2" id="У-чому-відмінність-БЕМ-від-oocss-amcss-smacss-suitcss"><a href="#У-чому-відмінність-БЕМ-від-oocss-amcss-smacss-suitcss" class="article__heading-anchor"></a>У чому відмінність БЕМ від OOCSS, AMCSS, SMACSS, SUITCSS?</h2><ol>
<li>БЕМ працює не тільки з CSS, але і з JavaScript.</li>
<li>БЕМ більше схожий з Web Components, ніж з перерахованими рішеннями для CSS. (<a href="#- Різниця-між-БЕМ-і-web-components">В чому різниця між БЕМ і Web Components?</a>)</li>
<li>БЕМ надає комплексне рішення по створенню архітектури проекту і допомагає організувати процеси розробки. Детальніше читайте у розділі <a href="../method/solved-problems/solved-problems.ru.md">Застосування методології для вирішення завдань веб-розробки</a>.</li>
</ol>
<blockquote>
<p>Докладніше про <a href="https://ru.bem.info/method/">методології БЕМ</a>.</p>
</blockquote>
<p>Можна використовувати БЕМ тільки на рівні CSS. Для цього досить просто слідувати <a href="../method/naming-convention/naming-convention.ru.md">рекомендацій методології</a>.</p>
<h2 class="article__heading article__heading_2" id="У-чому-різниця-між-БЕМ-і-web-components"><a href="#У-чому-різниця-між-БЕМ-і-web-components" class="article__heading-anchor"></a>У чому різниця між БЕМ і Web Components?</h2><p>Підтримка браузерів</p>
<ul>
<li>Web Components <a href="http://caniuse.com/#search=Web%20Components">не підтримується</a> в Safari, iOS Safari, Internet Explorer, Firefox.</li>
<li>БЕМ працює у всіх браузерах.</li>
</ul>
<p>Інкапсуляція</p>
<ul>
<li>У Web Components реалізована через Shadow DOM.</li>
<li>У БЕМ — з допомогою <a href="../method/key-concepts/key-concepts.ru.md#Елемент">елементів</a> блоку.</li>
</ul>
<p>Робота шаблонів</p>
<ul>
<li>У Web Components шаблони завжди виконуються в браузері. Це може вимагати додаткових рішень проблем з індексацією.</li>
<li>В БЭМ генерация шаблона возможна на этапе разработки. Це дозволяє віддавати готовий HTML. Шаблони можуть виконуватися як в браузері, так і на сервері.</li>
</ul>
<ul>
<li>Web Components использует императивный принцип — интерполяцию строк.</li>
<li>БЕМ використовує декларативний підхід, який дозволяє гнучко управляти шаблонизацией і уникати повторень. Докладно про різницю між декларативним та імперативним підходами дивіться у доповіді <a href="https://ru.bem.info/authors/berezhnoy-sergey/">Сергія Бережного</a> — <a href="https://events.yandex.ru/lib/talks/553/">Шаблонизаторы</a>.</li>
</ul>
<p>Замість імпорту HTML — збірка</p>
<ul>
<li>Web Components використовує імпорт HTML (HTML Imports), який працює безпосередньо в браузері. Для об&#39;єднання HTML-файлів використовується інструмент <a href="http://webcomponents.org/articles/introduction-to-html-imports/#aggregating-network-requests">Vulcanize</a>.</li>
<li>БЕМ використовує збирачі: <a href="https://ru.bem.info/tools/bem/enb-bem/">ENB</a> або <a href="https://ru.bem.info/tools/bem/bem-tools/">bem-tools</a>.</li>
</ul>
<p>Замість Custom Elements — абстракція над DOM-деревом</p>
<ul>
<li>У Web Components використовуються Custom Elements. Такий підхід дозволяє розмістити на одному DOM-вузол лише один компонент.</li>
<li>У БЕМ існує поняття <a href="../method/key-concepts/key-concepts.ru.md#БЕМ-дерево">БЕМ-дерева</a>. БЭМ использует <a href="../method/key-concepts/key-concepts.ru.md#Микс">миксы</a> — размещение нескольких БЭМ-сущностей на одном DOM-узле.</li>
</ul>
<h2 class="article__heading article__heading_2" id="У-чому-різниця-між-БЕМ-і-bootstrap"><a href="#У-чому-різниця-між-БЕМ-і-bootstrap" class="article__heading-anchor"></a>У чому різниця між БЕМ і Bootstrap?</h2><p>У термінах БЕМ <a href="http://getbootstrap.com/">Bootstrap</a> — це набір зверстаних блоків. БЕМ — не бібліотека елементів інтерфейсу, а методологія, що дозволяє:</p>
<ul>
<li>створювати архітектуру проекту;</li>
<li>розробляти веб-додатки незалежними блоками;</li>
<li>спрощувати підтримку проектів.</li>
</ul>
<p>Бібліотека блоків, зроблених на БЕМ — <a href="https://ru.bem.info/libs/bem-components/">bem-components</a>. Існують також і <a href="https://ru.bem.info/libs/">інші</a> БЕМ-бібліотеки.</p>
<h2 class="article__heading article__heading_2" id="В-якому-випадку-створювати-блок-у-якому--елемент"><a href="#В-якому-випадку-створювати-блок-у-якому--елемент" class="article__heading-anchor"></a>В якому випадку створювати блок, у якому — елемент?</h2><ol>
<li>Если фрагмент кода может использоваться повторно и не зависит от реализации других компонентов страницы, необходимо создавать <a href="../method/key-concepts/key-concepts.ru.md#Блок">блок</a>.</li>
<li>Если фрагмент кода не может использоваться самостоятельно, без родительской сущности (блока), в большинстве случаев создается <a href="../method/key-concepts/key-concepts.ru.md#Элемент">элемент</a>.</li>
</ol>
<p>Виняток становлять елементи, реалізація яких для спрощення розробки вимагає поділу на більш дрібні частини — подэлементы. БЕМ-методологія <a href="#Чому-у-БЕМ-не рекомендовано створювати елементи-елементів-block__elem1__elem2">не рекомендує створювати елементи елементів</a>. В подобном случае вместо элемента необходимо создавать служебный блок.</p>
<h2 class="article__heading article__heading_2" id="Чому-у-БЕМ-не-рекомендується-створювати-елементи-елементів-blockstrongelem1strongelem2"><a href="#Чому-у-БЕМ-не-рекомендується-створювати-елементи-елементів-blockstrongelem1strongelem2" class="article__heading-anchor"></a>Чому у БЕМ не рекомендується створювати елементи елементів (block<strong>elem1</strong>elem2)?</h2><p>Наявність елементів елементів обмежує можливість змінювати внутрішню структуру блоку: елементи можна поміняти місцями, видалити або додати без коригування існуючого коду.</p>
<p>У методології БЕМ вкладену структуру підтримують тільки блоки (<code>block__elem</code>). Ім&#39;я блоку задає простір імен, що <a href="../method/naming-convention/naming-convention.ru.md#Ім&#39;я%20елемента">гарантує залежність</a> елементів від блоку.</p>
<p>Блок може мати вкладену структуру елементів в DOM-дереві:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block__elem1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block__elem2"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block__elem3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>Однак ця ж структура блоку в методології БЕМ завжди буде представлена плоским списком елементів:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.block</span> {}
<span class="hljs-selector-class">.block__elem1</span> {}
<span class="hljs-selector-class">.block__elem2</span> {}
<span class="hljs-selector-class">.block__elem3</span> {}
</code></pre>
<p>Це дозволяє змінювати DOM-структуру блоку без внесення виправлень в коді кожного окремого елемента:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block__elem1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block__elem2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block__elem3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>Структура блоку змінюється, а правила для елементів і їх назви залишаються колишніми.</p>
<h2 class="article__heading article__heading_2" id="Навіщо-писати-ім39я-блоку-в-іменах-модифікаторів-і-елементів"><a href="#Навіщо-писати-ім39я-блоку-в-іменах-модифікаторів-і-елементів" class="article__heading-anchor"></a>Навіщо писати ім&#39;я блоку в іменах модифікаторів і елементів?</h2><p>Ім&#39;я блоку в іменах <a href="../method/key-concepts/key-concepts.ru.md#БЕМ-сутність">БЕМ-сутностей</a> забезпечує:</p>
<ul>
<li><a href="#Простір імен">Простір імен</a></li>
<li><a href="#Мікси">Мікси</a></li>
<li><a href="#Пошук-коді">Пошук в коді</a></li>
</ul>
<hr>
<p><strong>Важливо!</strong> Методологія БЕМ <a href="../method/naming-convention/naming-convention.ru.md#Альтернативні%20схеми-іменування">допускає вибір</a> зручної стратегії іменування, але вимагає дотримання консистентности в назвах. Так, например, все варианты верны: <code>context</code>, <code>ctx</code> или <code>c</code>, <code>attributes</code>, <code>attrs</code> или <code>as</code>. Необхідно вибрати один з них і використовувати у всьому проекті.</p>
<hr>
<h4 class="article__heading article__heading_4" id="Простір-імен"><a href="#Простір-імен" class="article__heading-anchor"></a>Простір імен</h4><p>Ім&#39;я блоку задає простір імен і забезпечує унікальність імен елементів і модифікаторів. Це дозволяє обмежити вплив елементів і модифікаторів одного блоку на реалізацію іншого.</p>
<h4 class="article__heading article__heading_4" id="Мікси"><a href="#Мікси" class="article__heading-anchor"></a>Мікси</h4><p><a href="../method/key-concepts/key-concepts.ru.md#Микс">Микс</a> — это совмещение разных БЭМ-сущностей на одном DOM-узле. При міксі модифікатора ім&#39;я блоку вказує, до якого блоку застосувати модифікатор. Якщо назва блоку не вказати модифікатор застосувати до всіх миксуемым БЕМ-сутностей.</p>
<p>Наприклад, розглянемо мікс пункту меню (<code>menu__item</code>) і кнопки (<code>button</code>):</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"menu__item button"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>Додамо модифікатор <code>active</code> у скороченій формі запису (без імені блоку):</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"menu__item button active"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>У такому вигляді HTML-розмітка не дає зрозуміти, до чого відноситься модифікатор: до пункту меню (<code>menu__item.active</code>) або до кнопки (<code>button.active</code>). Ім&#39;я блоку (<code>button_active</code>) явно вказує на БЕМ-сутність, до якої буде застосовано модифікатор.</p>
<p>Також запис <code>&lt;div class=&quot;block mod&quot;&gt;</code> не дає зрозуміти, які БЕМ-сутності використовуються в роботі. Наприклад, із запису <code>&lt;div class=&quot;checkbox button&quot;&gt;</code> не можна однозначно визначити, це мікс модифікатора і блоку або мікс двох блоків.</p>
<p>Повне ім&#39;я модифікатора <code>&lt;div class=&quot;block block_mod&quot;&gt;</code> показує, про яких сутності йдеться: <code>&lt;div class=&quot;checkbox checkbox_button&quot;&gt;</code>.</p>
<h4 class="article__heading article__heading_4" id="Пошук-в-коді"><a href="#Пошук-в-коді" class="article__heading-anchor"></a>Пошук в коді</h4><p>Явні та унікальні імена полегшують пошук необхідної сутності в коді і файловій системі.</p>
<p>Порівняємо результати глобального пошуку при налагодженні проекту. Знайдемо модифікатор <code>active</code>. У скороченому вигляді (<code>active</code>) в результати пошуку потраплять всі можливі комбінації і HTML-фрагменти, де зустрічається <code>active</code>. У запису, рекомендованої методологією, сама назва вже буде містити уточнюючий параметр у вигляді імені блоку (<code>button_active</code>). Так як ім&#39;я модифікатора унікально, в результати пошуку потраплять тільки потрібні фрагменти коду.</p>
<h2 class="article__heading article__heading_2" id="Як-зробити-глобальні-модифікатори-для-блоків"><a href="#Як-зробити-глобальні-модифікатори-для-блоків" class="article__heading-anchor"></a>Як зробити глобальні модифікатори для блоків?</h2><p>У БЕМ відсутнє поняття глобальних модифікаторів, так як модифікатор завжди відноситься до однієї конкретної <a href="../method/key-concepts/key-concepts.ru.md#БЕМ-сутність">БЕМ-сутності</a>.</p>
<p>Якщо потрібно винести CSS властивість за межі одного блоку і застосовувати його до різних БЕМ-сутностей в проекті, необхідно створювати окремий блок, реалізований в технології CSS.</p>
<p>БЕМ дозволяє поєднувати реалізацію різних блоків з допомогою <a href="../method/key-concepts/key-concepts.ru.md#Мікс">міксів</a>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block1 block2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h2 class="article__heading article__heading_2" id="Навіщо-створювати-окремі-директорії-і-файли-для-кожного-блоку-і-технології"><a href="#Навіщо-створювати-окремі-директорії-і-файли-для-кожного-блоку-і-технології" class="article__heading-anchor"></a>Навіщо створювати окремі директорії і файли для кожного блоку і технології?</h2><p>Файлова система БЕМ-проекту поділяється на вкладені директорії і файли для <a href="../method/filesystem/filesystem.ru.md#Реалізація-блоку-поділяється%20на%20окремі%20файли">зручності розробки і підтримки проекту</a>.</p>
<p>Дотримуватися <a href="../method/filesystem/filesystem.ru.md#Організація%20файлової%20системи-БЕМ-проекту">рекомендованої структури файлової системи</a> не обов&#39;язково. Ви можете використовувати будь-яку альтернативну структуру проекту, відповідну <a href="../method/filesystem/filesystem.ru.md#Принципи%20організації%20файлової%20системи-БЕМ-проекту">принципам організації файлової системи БЕМ</a>, наприклад:</p>
<p><strong>flex-схема</strong></p>
<ul>
<li>Блоку відповідає окрема директорія.</li>
<li>Елементи і модифікатори реалізовані в окремих файлах.</li>
</ul>
<pre><code class="lang-files">blocks/
  input/
      input_layout_horiz.css
      input_layout_vertical.css
      input__elem.css
      input.css
      input.js
  button/
</code></pre>
<ul>
<li>Блоку відповідає окрема директорія.</li>
<li>Елементи і модифікатори реалізовані у файлах блоку.</li>
</ul>
<pre><code class="lang-files">blocks/
  input/
      input.css
      input.js
  button/
</code></pre>
<ul>
<li>Директорії для блоків не використовуються.</li>
<li>Елементи і модифікатори реалізовані у файлах блоку.</li>
</ul>
<pre><code class="lang-files">blocks/
  input.css
  input.js
  button.css
  button.js
</code></pre>
<p><strong>flat-схема</strong></p>
<ul>
<li>Директорії для блоків не використовуються.</li>
<li>Опціональні элеметы і модифікатори реалізовані в окремих файлах.</li>
</ul>
<pre><code class="lang-files">blocks/
  input_type_search.js
  input_type_search.bemhtml
  input__box.bemhtml
  input.css
  input.js
  input.bemhtml
  button.css
  button.js
  button.bemhtml
  button.png
</code></pre>
<h2 class="article__heading article__heading_2" id="Навіщо-використовувати-i-bemjs-якщо-можна-писати-на-jquery"><a href="#Навіщо-використовувати-i-bemjs-якщо-можна-писати-на-jquery" class="article__heading-anchor"></a>Навіщо використовувати i-bem.js якщо можна писати на jQuery?</h2><p><a href="https://ru.bem.info/technology/i-bem/">i-bem.js</a> це спеціалізований фреймворк для розробки проектів на JavaScript в термінах блоків, елементів і модификаторв.</p>
<p><code>i-bem.js</code> не призначений для заміни фреймворку загального призначення, такого як jQuery.</p>
<p><code>i-bem.js</code> дозволяє:</p>
<ul>
<li>розробляти веб-інтерфейс в термінах блоків, елементів, модифікаторів;</li>
<li>інтегрувати JavaScript-код з шаблонами і CSS-правил в стилі БЕМ;</li>
<li>описувати логіку роботи блоку як набір станів.</li>
</ul>
<h2 class="article__heading article__heading_2" id="Чому-небажано-використовувати-вкладені-селектори"><a href="#Чому-небажано-використовувати-вкладені-селектори" class="article__heading-anchor"></a>Чому небажано використовувати вкладені селектори?</h2><p>Ключова ідея БЕМ — незалежність блоків. <a href="http://htmlbook.ru/css/selector/descendant">Вкладені селектори</a> збільшують зв&#39;язаність коду і роблять його повторне використання неможливим. Це суперечить принципам БЕМ.</p>
<p>Методологія БЕМ допускає використання таких селекторів, але рекомендує по-максимуму його скоротити.</p>
<p>Наприклад, вкладеність доречна, щоб змінювати елементи в залежності від стану блоку або заданої йому теми:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav_hovered</span> <span class="hljs-selector-class">.nav__link</span>
{
    <span class="hljs-attribute">text-decoration</span>: underline;
}
</code></pre>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav_theme_islands</span> <span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;
}
</code></pre>
<h2 class="article__heading article__heading_2" id="Чому-у-БЕМ-не-рекомендується-використовувати-комбіновані-селектори-для-створення-css-правил-до-модификатору"><a href="#Чому-у-БЕМ-не-рекомендується-використовувати-комбіновані-селектори-для-створення-css-правил-до-модификатору" class="article__heading-anchor"></a>Чому у БЕМ не рекомендується використовувати комбіновані селектори для створення CSS-правил до модификатору?</h2><p>Об&#39;єднані селектори ускладнюють перевизначення блоку, оскільки мають більш високу специфічність у CSS, ніж поодинокі. Специфічність комбінованого селектора модифікатора блоку (<code>.block1.mod</code>) і для переопределенного блоку (<code>.block2 .block1</code>) однакова. Перевизначення блоку буде залежати тільки від порядку оголошення правил у декларації.</p>
<p>Розглянемо приклад:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"header"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button active"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>Правила модификатора <code>active</code> для кнопки записываются как комбинированный селектор <code>.button.active</code>. При перевизначенні кнопки з допомогою батьківського блоку <code>header</code>, створюється селектор <code>.header .button</code>. Специфічність обох селекторів однакова, значить застосування CSS-правил визначається порядком їх оголошення в декларації.</p>
<p>Використання імені блоку в назві модифікатора забезпечує більш високий пріоритет CSS-правил при перевизначенні блоку.
Селектор <code>.header .button</code> завжди буде мати пріоритет вище, ніж <code>.button_active</code>.</p>
<blockquote>
<p><a href="#Навіщо писати-ім&#39;я-блоку в іменах-модифікаторів-і-елементів">Причини використання імені блоку імені модифікатора</a></p>
</blockquote>
<h2 class="article__heading article__heading_2" id="Можна-об39єднувати-тег-і-клас-в-селекторі-Наприклад-buttonbutton"><a href="#Можна-об39єднувати-тег-і-клас-в-селекторі-Наприклад-buttonbutton" class="article__heading-anchor"></a>Можна об&#39;єднувати тег і клас в селекторі? Наприклад, button.button.</h2><p>Поєднання тега і класу в селекторі підвищує специфічність CSS-правил. При додаванні модифікатора правила блоку не зможуть бути перевизначені, так як специфічність селектора блоку вище.</p>
<p>Розглянемо приклад:</p>
<pre><code class="lang-html"> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button"</span>&gt;</span>
</code></pre>
<p>Записуємо для нього CSS-правила в селекторі <code>button.button</code>.</p>
<p>Додамо модифікатор:</p>
<pre><code class="lang-html"> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button button_active"</span>&gt;</span>
</code></pre>
<p>Селектор <code>.button_active</code> не перевизначити властивості блоку, записані як <code>button.button</code>, так як специфічність <code>button.button</code> вище. Для успішного перевизначення селектор модифікатора блоку також повинен бути скомбінований з тегом <code>button.button_active</code>.</p>
<p>В результаті розвитку проекту можуть з&#39;явиться блоки з селекторами <code>input.button</code>, <code>span.button</code> і, наприклад, <code>a.button</code>. У такому разі всі модифікатори блоку <code>button</code> і вкладені в нього елементи зажадають чотири різні декларації для кожного випадку.</p>
<h2 class="article__heading article__heading_2" id="Чому-у-БЕМ-не-використовують-користувальницькі-теги-custom-tags-для-блоків"><a href="#Чому-у-БЕМ-не-використовують-користувальницькі-теги-custom-tags-для-блоків" class="article__heading-anchor"></a>Чому у БЕМ не використовують користувальницькі теги (custom tags) для блоків?</h2><blockquote>
<p>Блоки можуть виражатися в HTML з допомогою користувацьких тегів, до яких створюються CSS-правила. У такому разі класи можна буде використовувати тільки для модифікаторів: <code>&lt;button class=&quot;mod&quot;/&gt;</code>.</p>
</blockquote>
<p>Користувальницькі теги можуть застосовуватися для створення селекторів до блокам, але є ряд обмежень:</p>
<ul>
<li>Неможливо використовувати <a href="../method/key-concepts/key-concepts.ru.md#Мікс">мікси</a>.</li>
<li>Не будь блок можна виразити користувальницьким тегом. Наприклад, для всіх посилань необхідний тег <code>&lt;a&gt;</code>, а для полів — <code>&lt;input&gt;</code>.</li>
</ul>
<h2 class="article__heading article__heading_2" id="Чому-не-можна-робити-загальний-скид-стилів-reset"><a href="#Чому-не-можна-робити-загальний-скид-стилів-reset" class="article__heading-anchor"></a>Чому не можна робити загальний скид стилів (reset)?</h2><p>Блок — незалежний компонент. На нього не повинні впливати CSS-правила, створені для всієї сторінки. Це порушує незалежність блоків і ускладнює їх повторне використання.</p>
<p>Загальний скид стилів по суті реалізується з допомогою <a href="#Як зробити-глобальні-модифікатори-для-блоків">глобальних CSS-правил</a>, які в більшості випадків пишуться <a href="#Чому-у-БЕМ-не-використовують-користувальницькі теги-custom-tags-для-блоків">селекторам на тег</a>, що небажано використовувати в БЕМ-проекті.</p>
<p>Якщо скинути стилі все-таки необхідно, БЕМ це робиться в кожному блоці.</p>
<p>Розглянемо приклад. Якщо в проекті блоки меню і список виражені в HTML з допомогою тегу <code>&lt;ul&gt;</code>, значить кожен блок повинен надавати скидання CSS <code>&lt;ul&gt;</code>. Повторів у виводі коді можна уникнути за допомогою CSS-оптимізатора.</p>
<p>Якщо в проекті не використовується CSS-оптимізатор, який об&#39;єднує селектори з однаковим набором правил, можна застосувати CSS-препроцесор. Тоді для кожного нового блоку можна робити скидання правил, <a href="../method/key-concepts/key-concepts.ru.md#Мікс">міксуючи</a> чистий код. Наприклад, в SASS це буде виглядати так:</p>
<pre><code class="lang-css">.menu {
    @include reset-list;
}
.menu__item {
    @include reset-list-item;
}
...
.list {
    @include reset-list;
}
.list__item {
    @include reset-list-item;
}
</code></pre>
<p>Такий спосіб слід використовувати тільки при відсутності оптимізатора.</p>
<h2 class="article__heading article__heading_2" id="Чому-не-можна-писати-block_mod-замість-block-block_mod-якщо-ім39я-модифікатора-вже-містить-всю-інформацію-про-блоці"><a href="#Чому-не-можна-писати-block_mod-замість-block-block_mod-якщо-ім39я-модифікатора-вже-містить-всю-інформацію-про-блоці" class="article__heading-anchor"></a>Чому не можна писати block_mod замість block block_mod, якщо ім&#39;я модифікатора вже містить всю інформацію про блоці?</h2><p>Поєднання декількох модифікаторів на одному і тому ж блоці (наприклад, <code>&lt;div class=&quot;block_theme_christmas block_size_big&quot;&gt;</code>) призведе до дублювання коду, що реалізує базову функціональність (логіку і стилі) блоку.</p>
<h2 class="article__heading article__heading_2" id="Чому-не-можна-вказувати-назву-css-властивості-в-імені-модифікатора-block__element_border-color_grey"><a href="#Чому-не-можна-вказувати-назву-css-властивості-в-імені-модифікатора-block__element_border-color_grey" class="article__heading-anchor"></a>Чому не можна вказувати назву CSS-властивості в імені модифікатора: .block__element_border-color_grey?</h2><ul>
<li>При зміні зовнішнього вигляду блоку або елемента доведеться міняти не тільки CSS-код, але і назви селекторів. Наприклад, якщо колір кордону зміниться з сірого (<code>grey</code>) на червоний (<code>red</code>), потрібно буде змінити шаблони і, цілком ймовірно, JavaScript-код.</li>
<li>При додаванні інших властивостей (фону, відступів), ім&#39;я перестане відповідати вмісту модифікатора.</li>
</ul>
<p>Методологія БЕМ рекомендує вибирати імена модифікаторів, спираючись на семантику, а не візуальне оформлення.</p>
</div><ul class="article-rewind"><li class="article-rewind__prev"><a class="article-rewind__prev-link" href="/bem.info/uk/methodology/articles/">Статті</a></li></ul><div class="article-amendments">Якщо ви помітили помилку, або хочете доповнити статтю, ви завжди можете або написати нам про це на <a class="article-amendments__issue" href="https://github.com/bem/bem-method/issues/new">Гітхабі</a>, або поправити статтю з допомогою <a class="article-amendments__edit" href="http://prose.io/#bem/bem-method/blob/bem-info-data/faq/faq.uk.md">prose.io.</a></div><div class="social-likes"><a class="social-likes__text">Поділитися зі світом: </a><a class="social-likes__service social-likes__service_type_facebook" href="https://www.facebook.com/sharer.php?s=100&amp;url=https%3A%2F%2Fuk.bem.info%2Fmethodology%2Ffaq%2F&amp;title=FAQ&amp;image=">Facebook</a> <a class="social-likes__service social-likes__service_type_vk" href="http://vk.com/share.php?&amp;url=https%3A%2F%2Fuk.bem.info%2Fmethodology%2Ffaq%2F&amp;title=FAQ&amp;image=">VKontakte</a> <a class="social-likes__service social-likes__service_type_twitter" href="https://twitter.com/share?&amp;url=https%3A%2F%2Fuk.bem.info%2Fmethodology%2Ffaq%2F&amp;title=FAQ&amp;image=">Twitter</a></div></div></div><footer class="footer page-bg"><div class="legos legos_inverted"><div class="legos__lego legos__lego_height_4 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_6"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_6"></div><div class="legos__lego legos__lego_height_4 legos__lego_width_6"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_7"></div><div class="legos__lego legos__lego_height_1 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_4 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_1"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_6"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_4 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_1 legos__lego_width_2"></div><div class="legos__lego legos__lego_height_2 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_7"></div><div class="legos__lego legos__lego_height_1 legos__lego_width_4"></div><div class="legos__lego legos__lego_height_3 legos__lego_width_3"></div><div class="legos__lego legos__lego_height_4 legos__lego_width_2"></div></div><div class="footer__layout"><ul class="footer__community"><li class="footer__channel"><a class="footer__channel-link" href="https://web-standards.slack.com/messages/bem/">Slack</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://telegram.me/bem_ru">Telegram</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://www.facebook.com/groups/bem.info/">Facebook</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://twitter.com/bem_ru/">Twitter</a></li></ul></div></footer><script>(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter16972024 = new Ya.Metrika({"id":"16972024","webvisor":true,"clickmap":true,"trackLinks":true,"accurateTrackBounce":true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/16972024" style="position:absolute; left:-9999px;"/></div></noscript><script src="/bem.info/uk/methodology.uk.min.js"></script></body></html>